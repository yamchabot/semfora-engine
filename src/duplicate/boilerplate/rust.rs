//! Rust boilerplate pattern detection
//!
//! This module contains detection functions for common Rust boilerplate patterns
//! that should be excluded from duplicate detection.
//!
//! # Patterns Detected
//!
//! - **Trait Implementations**: Default, Clone, From, Into, Display, etc.
//! - **Builder Pattern**: with_*, set_*, builder, build methods
//! - **Getters**: get_*, is_*, has_*, can_*, should_* methods
//! - **Setters**: set_* methods (not builder pattern)
//! - **Constructors**: new, default, from_*, create_* methods
//! - **Conversions**: to_*, as_*, into_* methods
//! - **Derived Methods**: Methods generated by derive macros
//! - **Error From**: Error type From implementations
//! - **Iterators**: next, into_iter, iter, iter_mut
//! - **Deref/DerefMut**: Deref trait implementations
//! - **Drop**: Drop trait implementations
//! - **Tests**: test_* functions
//! - **Serde**: serialize_*, deserialize_*, visit_* methods

use super::{BoilerplateCategory, PatternMatcher};
use crate::lang::Lang;
use crate::schema::SymbolInfo;

/// All Rust boilerplate patterns
///
/// Order matters! Patterns are checked in order, so more specific patterns
/// should come before more general ones.
pub static PATTERNS: &[PatternMatcher] = &[
    // Test functions first (most specific, starts with test_)
    PatternMatcher {
        category: BoilerplateCategory::RustTest,
        languages: &[Lang::Rust],
        detector: is_rust_test,
        enabled_by_default: true,
    },
    // Trait implementations (specific method names)
    PatternMatcher {
        category: BoilerplateCategory::RustTraitImpl,
        languages: &[Lang::Rust],
        detector: is_rust_trait_impl,
        enabled_by_default: true,
    },
    // Builder pattern (with_*, set_*)
    PatternMatcher {
        category: BoilerplateCategory::RustBuilder,
        languages: &[Lang::Rust],
        detector: is_rust_builder,
        enabled_by_default: true,
    },
    // Getters (get_*, is_*, has_*)
    PatternMatcher {
        category: BoilerplateCategory::RustGetter,
        languages: &[Lang::Rust],
        detector: is_rust_getter,
        enabled_by_default: true,
    },
    // Setters (set_* that aren't builders)
    PatternMatcher {
        category: BoilerplateCategory::RustSetter,
        languages: &[Lang::Rust],
        detector: is_rust_setter,
        enabled_by_default: true,
    },
    // Constructors (new, from_*, create_*)
    PatternMatcher {
        category: BoilerplateCategory::RustConstructor,
        languages: &[Lang::Rust],
        detector: is_rust_constructor,
        enabled_by_default: true,
    },
    // Conversions (to_*, as_*, into_*)
    PatternMatcher {
        category: BoilerplateCategory::RustConversion,
        languages: &[Lang::Rust],
        detector: is_rust_conversion,
        enabled_by_default: true,
    },
    // Derived methods
    PatternMatcher {
        category: BoilerplateCategory::RustDerived,
        languages: &[Lang::Rust],
        detector: is_rust_derived,
        enabled_by_default: true,
    },
    // Error From implementations
    PatternMatcher {
        category: BoilerplateCategory::RustErrorFrom,
        languages: &[Lang::Rust],
        detector: is_rust_error_from,
        enabled_by_default: true,
    },
    // Iterator implementations
    PatternMatcher {
        category: BoilerplateCategory::RustIterator,
        languages: &[Lang::Rust],
        detector: is_rust_iterator,
        enabled_by_default: true,
    },
    // Deref implementations
    PatternMatcher {
        category: BoilerplateCategory::RustDeref,
        languages: &[Lang::Rust],
        detector: is_rust_deref,
        enabled_by_default: true,
    },
    // Drop implementations
    PatternMatcher {
        category: BoilerplateCategory::RustDrop,
        languages: &[Lang::Rust],
        detector: is_rust_drop,
        enabled_by_default: true,
    },
    // Serde helpers
    PatternMatcher {
        category: BoilerplateCategory::RustSerde,
        languages: &[Lang::Rust],
        detector: is_rust_serde,
        enabled_by_default: true,
    },
];

// =============================================================================
// Detection Functions
// =============================================================================

/// Rust test function: test_* or common test helper names
pub fn is_rust_test(info: &SymbolInfo) -> bool {
    // Name starts with test_
    if info.name.starts_with("test_") {
        return true;
    }

    // Common test helper patterns
    matches!(
        info.name.as_str(),
        "setup" | "teardown" | "setup_test" | "teardown_test" | "init_test" | "cleanup_test"
    )
}

/// Rust trait implementation: common trait methods with low complexity
pub fn is_rust_trait_impl(info: &SymbolInfo) -> bool {
    // Standard library trait implementations
    let trait_methods = [
        // Display/Debug
        "fmt",
        // Default
        "default",
        // Clone
        "clone",
        "clone_from",
        // PartialEq/Eq
        "eq",
        "ne",
        // PartialOrd/Ord
        "partial_cmp",
        "cmp",
        "lt",
        "le",
        "gt",
        "ge",
        // Hash
        "hash",
        // AsRef/AsMut
        "as_ref",
        "as_mut",
        // Borrow/BorrowMut
        "borrow",
        "borrow_mut",
        // From/Into
        "from",
        "into",
        // TryFrom/TryInto
        "try_from",
        "try_into",
        // FromStr
        "from_str",
        // ToString (Note: this conflicts with conversion, handle specially)
        "to_string",
        // Error
        "source",
        "description",
        "cause",
        // Index/IndexMut
        "index",
        "index_mut",
        // Add/Sub/Mul/Div etc (operator overloading)
        "add",
        "sub",
        "mul",
        "div",
        "rem",
        "neg",
        "not",
        "bitand",
        "bitor",
        "bitxor",
        "shl",
        "shr",
    ];

    // Check if it's a trait method name
    if !trait_methods.contains(&info.name.as_str()) {
        return false;
    }

    // Skip to_string - it's better classified as conversion
    if info.name == "to_string" {
        return false;
    }

    // Trait implementations should be simple
    info.control_flow.len() <= 2 && info.calls.len() <= 4
}

/// Rust builder pattern: with_* or set_* methods that return Self
pub fn is_rust_builder(info: &SymbolInfo) -> bool {
    let name = &info.name;

    // Builder patterns
    if name.starts_with("with_")
        || name.starts_with("set_")
        || name == "builder"
        || name == "build"
    {
        // Should have minimal logic - typically just field assignment
        return info.control_flow.len() <= 1 && info.calls.len() <= 3;
    }

    false
}

/// Rust getter: get_*, is_*, has_*, contains_* methods
pub fn is_rust_getter(info: &SymbolInfo) -> bool {
    let name = &info.name;

    // Getter patterns
    let is_getter_name = name.starts_with("get_")
        || name.starts_with("is_")
        || name.starts_with("has_")
        || name.starts_with("can_")
        || name.starts_with("should_")
        || name.starts_with("was_")
        || name.starts_with("will_")
        || name.starts_with("did_")
        || name.starts_with("contains_")
        || name.starts_with("exists_")
        || name.starts_with("needs_");

    if !is_getter_name {
        return false;
    }

    // Getters should have minimal logic
    info.control_flow.len() <= 1 && info.calls.len() <= 2
}

/// Rust setter: set_* methods (not builder pattern - no return)
pub fn is_rust_setter(info: &SymbolInfo) -> bool {
    if !info.name.starts_with("set_") {
        return false;
    }

    // Setters should have minimal logic - just assignment, maybe with simple validation
    info.control_flow.len() <= 1 && info.calls.len() <= 2
}

/// Rust constructor: new, default, from_*, try_from_*, with_*
pub fn is_rust_constructor(info: &SymbolInfo) -> bool {
    let name = &info.name;

    // Constructor patterns
    if name == "new"
        || name == "default"
        || name.starts_with("from_")
        || name.starts_with("try_from_")
        || name.starts_with("create_")
        || name.starts_with("make_")
        || name.starts_with("init_")
        || name.starts_with("with_")
        || name == "create"
        || name == "init"
        || name == "open"
        || name == "connect"
    {
        // Constructors can have moderate logic but shouldn't be too complex
        return info.control_flow.len() <= 2 && info.calls.len() <= 4;
    }

    false
}

/// Rust conversion: to_*, as_*, into_* methods
pub fn is_rust_conversion(info: &SymbolInfo) -> bool {
    let name = &info.name;

    // Conversion patterns
    if name.starts_with("to_")
        || name.starts_with("as_")
        || name.starts_with("into_")
        || name.starts_with("try_to_")
        || name.starts_with("try_as_")
        || name.starts_with("try_into_")
    {
        // Conversions should be simple
        return info.control_flow.len() <= 2 && info.calls.len() <= 3;
    }

    false
}

/// Rust derived: methods that look like derive-generated code
pub fn is_rust_derived(info: &SymbolInfo) -> bool {
    // Derive-generated methods are typically exact names
    matches!(
        info.name.as_str(),
        "clone" | "default" | "eq" | "ne" | "hash" | "cmp" | "partial_cmp" | "fmt"
    ) && info.control_flow.len() <= 1
        && info.calls.len() <= 2
}

/// Rust Error From implementation: from method with error conversion
pub fn is_rust_error_from(info: &SymbolInfo) -> bool {
    // From implementations typically named "from"
    if info.name != "from" {
        return false;
    }

    // Error conversions are usually simple wrappers
    info.control_flow.is_empty() && info.calls.len() <= 2
}

/// Rust iterator: next, into_iter, iter, iter_mut
pub fn is_rust_iterator(info: &SymbolInfo) -> bool {
    let iterator_methods = [
        "next",
        "into_iter",
        "iter",
        "iter_mut",
        "size_hint",
        "count",
        "last",
        "nth",
        "fold",
        "for_each",
        "collect",
        "partition",
        "all",
        "any",
        "find",
        "position",
        "max",
        "min",
        "sum",
        "product",
    ];

    // Check name matches and complexity is reasonable
    iterator_methods.contains(&info.name.as_str())
        && info.control_flow.len() <= 2
        && info.calls.len() <= 4
}

/// Rust Deref: deref and deref_mut
pub fn is_rust_deref(info: &SymbolInfo) -> bool {
    matches!(info.name.as_str(), "deref" | "deref_mut") && info.control_flow.is_empty()
}

/// Rust Drop: drop method
pub fn is_rust_drop(info: &SymbolInfo) -> bool {
    info.name == "drop" && info.control_flow.len() <= 1
}

/// Rust serde helpers: serialize_*, deserialize_*, with_*
pub fn is_rust_serde(info: &SymbolInfo) -> bool {
    let name = &info.name;

    // Serde patterns
    if name.starts_with("serialize_")
        || name.starts_with("deserialize_")
        || name == "serialize"
        || name == "deserialize"
        || name.starts_with("visit_")
        || name == "expecting"
    {
        return true;
    }

    // Serde attribute helpers
    if name.starts_with("default_") || name.starts_with("skip_") || name.starts_with("rename_") {
        return info.control_flow.is_empty() && info.calls.len() <= 1;
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::duplicate::boilerplate::tests::make_symbol;

    // =========================================================================
    // Test Function Tests
    // =========================================================================

    #[test]
    fn test_rust_test_detection() {
        let symbol = make_symbol("test_user_creation", vec!["create_user", "assert_eq"], 0);
        assert!(is_rust_test(&symbol));
    }

    #[test]
    fn test_rust_test_with_setup() {
        let symbol = make_symbol("test_handles_errors", vec!["setup", "run", "assert"], 1);
        assert!(is_rust_test(&symbol));
    }

    #[test]
    fn test_rust_test_not_test() {
        let symbol = make_symbol("user_creation", vec!["create_user"], 0);
        assert!(!is_rust_test(&symbol));
    }

    #[test]
    fn test_rust_test_setup_helper() {
        let symbol = make_symbol("setup", vec!["init"], 0);
        assert!(is_rust_test(&symbol));
    }

    // =========================================================================
    // Trait Implementation Tests
    // =========================================================================

    #[test]
    fn test_rust_trait_impl_fmt() {
        let symbol = make_symbol("fmt", vec!["write!", "f.write_str"], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_clone() {
        let symbol = make_symbol("clone", vec!["clone"], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_eq() {
        let symbol = make_symbol("eq", vec![], 1);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_hash() {
        let symbol = make_symbol("hash", vec!["state.write", "hash"], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_from() {
        let symbol = make_symbol("from", vec!["new"], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_into() {
        let symbol = make_symbol("into", vec![], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_try_from() {
        let symbol = make_symbol("try_from", vec!["validate"], 1);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_try_into() {
        let symbol = make_symbol("try_into", vec![], 1);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_default() {
        let symbol = make_symbol("default", vec![], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_cmp() {
        let symbol = make_symbol("cmp", vec!["cmp"], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_partial_cmp() {
        let symbol = make_symbol("partial_cmp", vec!["cmp"], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_description() {
        let symbol = make_symbol("description", vec![], 0);
        assert!(is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_not_matched() {
        let symbol = make_symbol(
            "fmt",
            vec!["validate", "process", "transform", "encode", "write"],
            3,
        );
        assert!(!is_rust_trait_impl(&symbol));
    }

    #[test]
    fn test_rust_trait_impl_not_trait_method() {
        let symbol = make_symbol("process_data", vec!["run"], 0);
        assert!(!is_rust_trait_impl(&symbol));
    }

    // =========================================================================
    // Builder Pattern Tests
    // =========================================================================

    #[test]
    fn test_rust_builder_with_prefix() {
        let symbol = make_symbol("with_name", vec!["self"], 0);
        assert!(is_rust_builder(&symbol));
    }

    #[test]
    fn test_rust_builder_with_config() {
        let symbol = make_symbol("with_config", vec![], 0);
        assert!(is_rust_builder(&symbol));
    }

    #[test]
    fn test_rust_builder_with_capacity() {
        let symbol = make_symbol("with_capacity", vec!["Vec::with_capacity"], 0);
        assert!(is_rust_builder(&symbol));
    }

    #[test]
    fn test_rust_builder_builder_method() {
        let symbol = make_symbol("builder", vec!["Default::default"], 0);
        assert!(is_rust_builder(&symbol));
    }

    #[test]
    fn test_rust_builder_build_method() {
        let symbol = make_symbol("build", vec!["validate", "construct"], 0);
        assert!(is_rust_builder(&symbol));
    }

    #[test]
    fn test_rust_builder_set_prefix() {
        let symbol = make_symbol("set_name", vec!["self"], 0);
        assert!(is_rust_builder(&symbol));
    }

    #[test]
    fn test_rust_builder_too_complex() {
        let symbol = make_symbol(
            "with_validation",
            vec!["validate", "process", "transform", "encode"],
            2,
        );
        assert!(!is_rust_builder(&symbol));
    }

    // =========================================================================
    // Getter Tests
    // =========================================================================

    #[test]
    fn test_rust_getter_get_prefix() {
        let symbol = make_symbol("get_name", vec![], 0);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_get_user_id() {
        let symbol = make_symbol("get_user_id", vec!["clone"], 0);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_is_prefix() {
        let symbol = make_symbol("is_empty", vec![], 0);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_is_valid() {
        let symbol = make_symbol("is_valid", vec![], 1);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_has_prefix() {
        let symbol = make_symbol("has_children", vec!["len"], 0);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_can_prefix() {
        let symbol = make_symbol("can_read", vec![], 1);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_should_prefix() {
        let symbol = make_symbol("should_retry", vec![], 1);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_contains_prefix() {
        let symbol = make_symbol("contains_key", vec!["get"], 0);
        assert!(is_rust_getter(&symbol));
    }

    #[test]
    fn test_rust_getter_too_complex() {
        let symbol = make_symbol(
            "get_computed_value",
            vec!["fetch", "parse", "validate", "transform"],
            2,
        );
        assert!(!is_rust_getter(&symbol));
    }

    // =========================================================================
    // Setter Tests
    // =========================================================================

    #[test]
    fn test_rust_setter_basic() {
        let symbol = make_symbol("set_name", vec![], 0);
        assert!(is_rust_setter(&symbol));
    }

    #[test]
    fn test_rust_setter_user_id() {
        let symbol = make_symbol("set_user_id", vec![], 0);
        assert!(is_rust_setter(&symbol));
    }

    #[test]
    fn test_rust_setter_with_validation() {
        let symbol = make_symbol("set_age", vec!["validate"], 1);
        assert!(is_rust_setter(&symbol));
    }

    #[test]
    fn test_rust_setter_too_complex() {
        let symbol = make_symbol(
            "set_config",
            vec!["parse", "validate", "transform", "persist"],
            2,
        );
        assert!(!is_rust_setter(&symbol));
    }

    #[test]
    fn test_rust_setter_not_setter() {
        let symbol = make_symbol("get_name", vec![], 0);
        assert!(!is_rust_setter(&symbol));
    }

    // =========================================================================
    // Constructor Tests
    // =========================================================================

    #[test]
    fn test_rust_constructor_new() {
        let symbol = make_symbol("new", vec!["Default::default"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_new_with_init() {
        let symbol = make_symbol("new", vec!["init"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_default() {
        let symbol = make_symbol("default", vec![], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_from_str() {
        let symbol = make_symbol("from_str", vec!["parse"], 1);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_from_bytes() {
        let symbol = make_symbol("from_bytes", vec!["decode"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_from_parts() {
        let symbol = make_symbol("from_parts", vec![], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_create_instance() {
        let symbol = make_symbol("create_instance", vec!["allocate"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_init() {
        let symbol = make_symbol("init", vec!["setup"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_init_with_config() {
        let symbol = make_symbol("init_with_config", vec!["load_config"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_make_server() {
        let symbol = make_symbol("make_server", vec!["bind"], 0);
        assert!(is_rust_constructor(&symbol));
    }

    #[test]
    fn test_rust_constructor_too_complex() {
        let symbol = make_symbol(
            "new",
            vec!["validate", "setup", "connect", "authenticate", "configure"],
            3,
        );
        assert!(!is_rust_constructor(&symbol));
    }

    // =========================================================================
    // Conversion Tests
    // =========================================================================

    #[test]
    fn test_rust_conversion_to_string() {
        let symbol = make_symbol("to_string", vec!["format!"], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_to_vec() {
        let symbol = make_symbol("to_vec", vec!["clone"], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_to_owned() {
        let symbol = make_symbol("to_owned", vec![], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_as_ref() {
        let symbol = make_symbol("as_ref", vec![], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_as_slice() {
        let symbol = make_symbol("as_slice", vec![], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_as_bytes() {
        let symbol = make_symbol("as_bytes", vec![], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_into_inner() {
        let symbol = make_symbol("into_inner", vec![], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_into_vec() {
        let symbol = make_symbol("into_vec", vec![], 0);
        assert!(is_rust_conversion(&symbol));
    }

    #[test]
    fn test_rust_conversion_too_complex() {
        let symbol = make_symbol(
            "to_json",
            vec!["serialize", "validate", "transform", "encode"],
            2,
        );
        assert!(!is_rust_conversion(&symbol));
    }

    // =========================================================================
    // Derived Method Tests
    // =========================================================================

    #[test]
    fn test_rust_derived_clone() {
        let symbol = make_symbol("clone", vec!["clone"], 0);
        assert!(is_rust_derived(&symbol));
    }

    #[test]
    fn test_rust_derived_default() {
        let symbol = make_symbol("default", vec![], 0);
        assert!(is_rust_derived(&symbol));
    }

    #[test]
    fn test_rust_derived_with_simple_call() {
        let symbol = make_symbol("clone", vec!["clone", "clone"], 0);
        assert!(is_rust_derived(&symbol));
    }

    #[test]
    fn test_rust_derived_not_derived() {
        let symbol = make_symbol("clone", vec!["validate", "transform", "deep_clone"], 1);
        assert!(!is_rust_derived(&symbol));
    }

    #[test]
    fn test_rust_derived_not_derived_name() {
        let symbol = make_symbol("process", vec![], 0);
        assert!(!is_rust_derived(&symbol));
    }

    // =========================================================================
    // Error From Tests
    // =========================================================================

    #[test]
    fn test_rust_error_from() {
        let symbol = make_symbol("from", vec!["new", "Error::new"], 0);
        assert!(is_rust_error_from(&symbol));
    }

    #[test]
    fn test_rust_error_from_into() {
        let symbol = make_symbol("from", vec!["into"], 0);
        assert!(is_rust_error_from(&symbol));
    }

    #[test]
    fn test_rust_error_from_too_complex() {
        let symbol = make_symbol(
            "from",
            vec!["validate", "parse", "transform", "wrap_error"],
            2,
        );
        assert!(!is_rust_error_from(&symbol));
    }

    // =========================================================================
    // Iterator Tests
    // =========================================================================

    #[test]
    fn test_rust_iterator_next() {
        let symbol = make_symbol("next", vec!["next"], 1);
        assert!(is_rust_iterator(&symbol));
    }

    #[test]
    fn test_rust_iterator_next_simple() {
        let symbol = make_symbol("next", vec![], 1);
        assert!(is_rust_iterator(&symbol));
    }

    #[test]
    fn test_rust_iterator_into_iter() {
        let symbol = make_symbol("into_iter", vec!["IntoIterator::into_iter"], 0);
        assert!(is_rust_iterator(&symbol));
    }

    #[test]
    fn test_rust_iterator_iter() {
        let symbol = make_symbol("iter", vec![], 0);
        assert!(is_rust_iterator(&symbol));
    }

    #[test]
    fn test_rust_iterator_iter_mut() {
        let symbol = make_symbol("iter_mut", vec![], 0);
        assert!(is_rust_iterator(&symbol));
    }

    #[test]
    fn test_rust_iterator_too_complex() {
        let symbol = make_symbol("next", vec!["fetch", "parse", "transform", "cache", "emit"], 3);
        assert!(!is_rust_iterator(&symbol));
    }

    // =========================================================================
    // Deref Tests
    // =========================================================================

    #[test]
    fn test_rust_deref() {
        let symbol = make_symbol("deref", vec![], 0);
        assert!(is_rust_deref(&symbol));
    }

    #[test]
    fn test_rust_deref_mut() {
        let symbol = make_symbol("deref_mut", vec![], 0);
        assert!(is_rust_deref(&symbol));
    }

    #[test]
    fn test_rust_deref_not_matched() {
        let symbol = make_symbol("dereference", vec![], 0);
        assert!(!is_rust_deref(&symbol));
    }

    // =========================================================================
    // Drop Tests
    // =========================================================================

    #[test]
    fn test_rust_drop() {
        let symbol = make_symbol("drop", vec!["close", "cleanup"], 0);
        assert!(is_rust_drop(&symbol));
    }

    #[test]
    fn test_rust_drop_simple() {
        let symbol = make_symbol("drop", vec![], 0);
        assert!(is_rust_drop(&symbol));
    }

    #[test]
    fn test_rust_drop_not_matched() {
        let symbol = make_symbol("drop_all", vec![], 0);
        assert!(!is_rust_drop(&symbol));
    }

    // =========================================================================
    // Serde Tests
    // =========================================================================

    #[test]
    fn test_rust_serde_serialize() {
        let symbol = make_symbol("serialize", vec!["serializer.serialize_struct"], 0);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_serialize_field() {
        let symbol = make_symbol("serialize_field", vec!["write"], 0);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_deserialize() {
        let symbol = make_symbol("deserialize", vec!["deserializer.deserialize_struct"], 1);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_deserialize_field() {
        let symbol = make_symbol("deserialize_field", vec!["read"], 0);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_visit_str() {
        let symbol = make_symbol("visit_str", vec!["from_str"], 1);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_visit_map() {
        let symbol = make_symbol("visit_map", vec!["next_key", "next_value"], 1);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_visit_seq() {
        let symbol = make_symbol("visit_seq", vec!["next_element"], 1);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_expecting() {
        let symbol = make_symbol("expecting", vec!["write_str"], 0);
        assert!(is_rust_serde(&symbol));
    }

    #[test]
    fn test_rust_serde_not_matched() {
        let symbol = make_symbol("process_data", vec!["parse"], 0);
        assert!(!is_rust_serde(&symbol));
    }

    // =========================================================================
    // Integration Tests
    // =========================================================================

    #[test]
    fn test_classify_rust_boilerplate_all_types() {
        use crate::duplicate::boilerplate::classify_boilerplate;

        // Test function
        let test = make_symbol("test_something", vec!["assert"], 0);
        assert_eq!(
            classify_boilerplate(&test, None),
            Some(BoilerplateCategory::RustTest)
        );

        // Trait impl
        let fmt = make_symbol("fmt", vec!["write!"], 0);
        assert_eq!(
            classify_boilerplate(&fmt, None),
            Some(BoilerplateCategory::RustTraitImpl)
        );

        // Builder
        let with_name = make_symbol("with_name", vec![], 0);
        assert_eq!(
            classify_boilerplate(&with_name, None),
            Some(BoilerplateCategory::RustBuilder)
        );

        // Getter
        let get_name = make_symbol("get_name", vec![], 0);
        assert_eq!(
            classify_boilerplate(&get_name, None),
            Some(BoilerplateCategory::RustGetter)
        );

        // Constructor
        let new = make_symbol("new", vec![], 0);
        assert_eq!(
            classify_boilerplate(&new, None),
            Some(BoilerplateCategory::RustConstructor)
        );

        // Conversion
        let to_string = make_symbol("to_string", vec![], 0);
        assert_eq!(
            classify_boilerplate(&to_string, None),
            Some(BoilerplateCategory::RustConversion)
        );

        // Iterator
        let next = make_symbol("next", vec![], 1);
        assert_eq!(
            classify_boilerplate(&next, None),
            Some(BoilerplateCategory::RustIterator)
        );

        // Deref
        let deref = make_symbol("deref", vec![], 0);
        assert_eq!(
            classify_boilerplate(&deref, None),
            Some(BoilerplateCategory::RustDeref)
        );

        // Drop
        let drop = make_symbol("drop", vec![], 0);
        assert_eq!(
            classify_boilerplate(&drop, None),
            Some(BoilerplateCategory::RustDrop)
        );

        // Serde
        let serialize = make_symbol("serialize", vec![], 0);
        assert_eq!(
            classify_boilerplate(&serialize, None),
            Some(BoilerplateCategory::RustSerde)
        );
    }

    #[test]
    fn test_rust_boilerplate_disabled() {
        use crate::duplicate::boilerplate::{classify_boilerplate, BoilerplateConfig, BuiltinBoilerplate};

        let mut builtin = BuiltinBoilerplate::default();
        builtin.disable(BoilerplateCategory::RustTest);
        builtin.disable(BoilerplateCategory::RustTraitImpl);
        builtin.disable(BoilerplateCategory::RustBuilder);
        builtin.disable(BoilerplateCategory::RustGetter);

        let config = BoilerplateConfig {
            builtin,
            custom: vec![],
        };

        // Should not match when disabled
        let test = make_symbol("test_something", vec!["assert"], 0);
        assert_ne!(
            classify_boilerplate(&test, Some(&config)),
            Some(BoilerplateCategory::RustTest)
        );

        let fmt = make_symbol("fmt", vec!["write!"], 0);
        assert_ne!(
            classify_boilerplate(&fmt, Some(&config)),
            Some(BoilerplateCategory::RustTraitImpl)
        );
    }
}
